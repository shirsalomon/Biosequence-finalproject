Implemented Extensions
4.1 Quality Filtering
Reads and k-mers with low quality scores are filtered out to improve alignment accuracy.
Explanation:
The average quality of each read is computed using the _calculate_quality_mean() function.
If the quality falls below the threshold specified by the user (--min-read-quality), the read is excluded from the alignment process.
4.2 Reverse Complement Support
Enables alignment of reads against reverse-complemented genome sequences, ensuring detection of matches on both DNA strands.
Explanation:
Since reads may originate from either strand of the DNA double helix, alignment must account for both the original and reverse complement of each read.
The reverse_complement() function transforms each read into its reverse-complemented sequence, replacing A↔T and G↔C while reversing the order.
find_matches() compares each read to both orientations to ensure comprehensive matching.
4.3 Coverage Tracking
Tracks how many reads align to each genome region, providing insight into sequence coverage.
Explanation:
The initialize_coverage() function sets up a data structure for tracking coverage across all reference genomes.
find_matches() updates the hit count for each genome.
save_coverage_data() exports the final coverage statistics to a JSON file.
4.4 Genome Similarity Filtering
Removes nearly identical genomes from the reference database to reduce ambiguity and noise during alignment.
Explanation:
The filter_similar_genomes() function calculates pairwise similarity between genomes based on shared k-mers.
If two genomes exceed a specified similarity threshold (--similarity-threshold), one is discarded.
This helps avoid redundant alignments and improves the clarity of alignment results.

Design Decisions
1. Choice of K-mer Length (K = 31)
A k-mer length of 31 was chosen based on common practices in bioinformatics tools such as SPAdes, Kraken, and KMC.
This length balances sensitivity (capturing short sequences) with specificity (reducing random matches).
While longer k-mers improve accuracy, they may reduce the likelihood of detecting partial or noisy matches.
2. Database Storage Format
The reference database is stored in a dedicated KDB (K-mer Database) format to allow fast and efficient lookups.
This structure enables quick retrieval of matching genomes for any given k-mer without scanning the entire dataset.
3. Reverse Complement Handling
Instead of storing precomputed reverse-complement sequences for every genome, the comparison is performed dynamically at runtime.
This approach significantly reduces memory usage while maintaining alignment accuracy.
4. Filtering Similar Genomes
Genome similarity is computed using Jaccard similarity based on shared k-mer sets.
If the similarity between two genomes exceeds a predefined threshold, one of them is excluded.
This prevents redundancy and reduces false-positive alignments due to overlapping references.

## Video Presentation

A short explanation and demonstration of the tool is available here:  
[Watch the video] https://www.youtube.com/watch?v=904jeoKXPoI
